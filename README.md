## Створити сервер, який:
1. Приймає вебхуки ордерів від платіжної системи (на `POST /webhooks/payments/orders`), обробляє їх, записує необхідні дані в БД і надсилає підключеним клієнтам (через `GET /orders/{order_id}/events`) івенти по ордерам, використовуючи SSE stream.
2. Має ендпойнт для отримання даних по ордерам (`GET /orders`) (бонус: з можливістю фільтрації та сортування).

## Деталі:
### 1.
Маємо гіпотетичну платіжну систему JustPay!, через яку користувачі здійснюють платежі.
JustPay! не гарантує правильний порядок надсилання вебхуків зі статусами ордерів.
Проте, JustPay! гарантує, що created_at та updated_at вебхука будуть відповідати реальному часу створення та оновлення ордера в JustPay!.

Статуси ордерів, які приходять з вебхуками від JustPay! (цикл життя ордеру):

* `cool_order_created` - JustPay! прийняла замовлення і створила його.
* `sbu_verification_pending` - JustPay! очікує підтвердження платежу від банку. Цей статус може прийти після створення ордера (cool_order_created).
* `confirmed_by_mayor` - JustPay! отримала підтвердження від банку. Цей статус означає, що попередньо замовлення вже буле створено (cool_order_created), відправлено на розгляд до банку (sbu_verification_pending) і банк підтвердив, що платіж може бути здійснений.

* `changed_my_mind` - замовлення скасовано. Це один з можливих фінальних статусів ордера. Цей статус може прийти в будь-який момент після створення ордеру і до отримання будь-якого іншого фінального статусу або статусу chinazes.
* `failed` - платіж не пройшов. Це один з можливих фінальних статусів ордера. Цей статус може прийти в будь-який момент після створення ордеру і до отримання будь-якого іншого фінального статусу або статусу chinazes.
* `chinazes` - платіж пройшов успішно. Цей статус може прийти лише після успішного підтвердження (confirmed_by_mayor) платежу банком-емітентом. Це єдиний статус, який означає, що платіж було успішно здійснено. Якщо пройшло 30 секунд від моменту отримання статусу chinazes і не прийшло статусу give_my_money_back, то статус ордера вважається фінальним.

* `give_my_money_back` - платіж повернуто. Це один з можливих фінальних статусів ордера. Цей статус може прийти лише якщо ордер було попередньо оплачено. Цей статус не може прийти пізніше, ніж через 30 секунд після отримання статусу chinazes.

Вебхуки надсилаються на ендпойнт `POST /webhooks/payments/orders` з JSON-ом в тілі запиту.
Приклад вебхука:

```json
{
    "event_id": "483ec8f8-4864-427b-a878-ca026fd38f88",
    "order_id": "97a96c29-7631-4cbc-9559-f8866fb03392",
    "user_id": "2c127d70-3b9b-4743-9c2e-74b9f617029f",
    "order_status": "cool_order_created|confirmed_by_mayor|sbu_verification_pending|changed_my_mind|failed|give_my_money_back|chinazes",
    "updated_at":"2019-01-01T00:00:00Z",
    "created_at": "2019-01-01T00:00:00Z"
}
```

Сервер повинен обробляти вебхук, зберігати дані в БД та відповідати HTTP статусом 200.
Якщо вебхук для ордера прийшов вже після отримання фінального статусу, сервер повинен відповісти HTTP статусом 410.

Вебхуки мають унікальний id (event_id). Якщо сервер отримує вебхук з ідентифікатором, який вже був оброблений або в процесі обробки, сервер повинен відповісти HTTP статусом 409.

Якщо по якійсь причині сервер не обробив вебхук, то сервер повинен відповісти будь-яким статусом 4хх-5хх, окрім 409, 410, 200. В такому разі JustPay! надішле вебхук повторно з тим же event_id.


--------------------------------------------
Ендпойнт `GET /orders/{order_id}/events` для стрімінгу івентів по ордерам через SSE.

До нього підключаються клієнти для отримання даних по ордерам через SSE (server-side events).
Якщо вебхуки приходять в неправильному порядку, сервер повинен забезпечити правильний порядок подій для клієнта.

Дані повинні надсилатися по мірі їх отримання від JustPay!, або з БД, якщо того потребує реалізація. Допускається затримка відправки даних, якщо сервер очікує на інші вебхуки для ордера, щоб забезпечити правильний порядок івентів.
Наприклад, якщо прийшли вебхуки зі статусами `cool_order_created` та `chinazes`, але вебхуки зі статусами `sbu_verification_pending`, `confirmed_by_mayor` ще не прийшли, сервер мусить почекати на них перед відправкою подій клієнту, щоб забезпечити правильний порядок цих івентів.

Клієнтів, підключених до SSE стріму, може бути декілька (один і більше).
Клієнти можуть підключатись до стріму у будь-який момент часу.
Всі клієнти мають отримувати однакові івенти і в однаковому порядку по конкретному ордеру.
Конекшн до клієнта повинен бути відкритий до тих пір, поки ордер не отримає фінальний статус.

Якщо клієнт підключився у будь-який момент циклу життя ордера, сервер повинен надіслати клієнту всі події, які відбулися з ордером до моменту підключення.
Якщо клієнт підключився після отримання фінального статусу, сервер також повинен надіслати клієнту всі події, які відбулися з ордером, та закрити конекшн.
Якщо клієнт підключився до ордера, по якому ще не було вебхуків, сервер повинен почекати на вебхуки. Якщо вебхуки не приходять протягом 1 хв, сервер повинен закрити конекшн.

Приклад стрім івенту:

```json
{
    "order_id": "97a96c29-7631-4cbc-9559-f8866fb03392",
    "user_id": "2c127d70-3b9b-4743-9c2e-74b9f617029f",
    "order_status": "cool_order_created",
    "is_final": false,
    "created_at": "2019-01-01T00:00:00Z",
    "updated_at": "2019-01-01T00:00:00Z"
}
```

### 2.
Ендпойнт `GET /orders`. При запиті повертається список (масив) обʼєктів ордерів.

Приклад респонзу:

```json
[
    {
        "order_id": "97a96c29-7631-4cbc-9559-f8866fb03392",
        "user_id": "2c127d70-3b9b-4743-9c2e-74b9f617029f",
        "status": "cool_order_created",
        "is_final": false,
        "created_at": "2019-01-01T00:00:00Z",
        "updated_at": "2019-01-01T00:00:00Z"
    }, 
    {
        "order_id": "e54a6ce0-b1d4-4dbf-a479-22f2fa575b0e",
        "user_id": "6d76f7a7-1a11-4c30-b57c-7873a5f87167",
        "status": "chinazes",
        "is_final": true,
        "created_at": "2019-01-01T00:00:00Z",
        "updated_at": "2019-01-01T00:00:00Z"
    }
]
```

Буде плюсом в карму, якщо сервер зможе фільтрувати і сортувати ордера по цьому ендпойнту через квері параметри.

Query параметри для фільтрації і сортування ордерів:
- `status` - статус ордера (може бути декілька значень, через кому). Якщо параметр не передано, повертати всі ордери. Обовʼязкове, якщо не вказано is_final.
- `user_id` - id користувача. Не обовʼязковий параметр.
- `limit` - кількість ордерів, які повертаються. За замовчуванням 10.
- `offset` - з якого ордера по порядку повертати. За замовчуванням 0.
- `is_final` - фінальний статус ордера (true|false). Якщо параметр не передано, повертати всі ордери. Обовʼязкове, якщо не вказано status.
- `sort_by` - поле, по якому сортувати ордери (created_at|updated_at). За замовчуванням created_at.
- `sort_order` - порядок сортування (asc|desc). За замовчуванням desc.

Може бути вказано або `is_final`, або `status`. Якщо вказано обидва параметри, повертати Bad Request 400, навіть якщо набір статусів в `status` не конфліктує з `is_final` значенням (`status=chinazes&is_final=true`).


Технічні вимоги:

0. Мова програмування - Go.
1. Можна використовувати будь-які фреймворки або бібліотеки на Ваш вибір.
2. БД бажано реляційна (SQLite, PostgreSQL, MySQL, тощо).
3. Бажано - низькорівневий SQL-драйвер. Але можна використовувати ORM.
4. Будь ласка, забезпечте можливість запуску сервера і необхідної інфраструктури (БД) локально. Наприклад, через docker-compose.

Good luck and have fun! :)